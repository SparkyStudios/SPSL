using System.Text;
using Antlr4.StringTemplate;
using SPSL.Language;
using SPSL.Language.AST;
using SPSL.Translation.Common;

namespace SPSL.Translation.HLSL;

public class Translator
{

    private static string TranslateOp(string op)
    {
        switch (op)
        {
            case "and": return "&&";
            case "or": return "||";
            default: return op;
        }
    }

    private static string TranslateBuiltInType(BuiltInDataTypeKind type)
    {
        return type switch
        {
            BuiltInDataTypeKind.ArrayCubemap => "TextureCubeArray",
            BuiltInDataTypeKind.ArrayTexture1D => "Texture1DArray",
            BuiltInDataTypeKind.ArrayTexture2D => "Texture2DArray",
            BuiltInDataTypeKind.Color3 => "float3",
            BuiltInDataTypeKind.Color4 => "float4",
            BuiltInDataTypeKind.Cubemap => "TextureCube",
            BuiltInDataTypeKind.Matrix2f => "float2x2",
            BuiltInDataTypeKind.Matrix2x3f => "float2x3",
            BuiltInDataTypeKind.Matrix2x4f => "float2x4",
            BuiltInDataTypeKind.Matrix3f => "float3x3",
            BuiltInDataTypeKind.Matrix3x2f => "float3x2",
            BuiltInDataTypeKind.Matrix3x4f => "float3x4",
            BuiltInDataTypeKind.Matrix4f => "float4x4",
            BuiltInDataTypeKind.Matrix4x2f => "float4x2",
            BuiltInDataTypeKind.Matrix4x3f => "float4x3",
            BuiltInDataTypeKind.Sampler => "SamplerState",
            BuiltInDataTypeKind.Texture1D => "Texture1D",
            BuiltInDataTypeKind.Texture2D => "Texture2D",
            BuiltInDataTypeKind.Texture3D => "Texture3D",
            BuiltInDataTypeKind.Vector2b => "bool2",
            BuiltInDataTypeKind.Vector2f => "float2",
            BuiltInDataTypeKind.Vector2i => "int2",
            BuiltInDataTypeKind.Vector2ui => "uint2",
            BuiltInDataTypeKind.Vector3b => "bool3",
            BuiltInDataTypeKind.Vector3f => "float3",
            BuiltInDataTypeKind.Vector3i => "int3",
            BuiltInDataTypeKind.Vector3ui => "uint3",
            BuiltInDataTypeKind.Vector4b => "bool4",
            BuiltInDataTypeKind.Vector4f => "float4",
            BuiltInDataTypeKind.Vector4i => "int4",
            BuiltInDataTypeKind.Vector4ui => "uint4",
            _ => string.Empty,
        };
    }

    private static string TranslatePrimitiveType(PrimitiveDataTypeKind type)
    {
        return type switch
        {
            PrimitiveDataTypeKind.Boolean => "bool",
            PrimitiveDataTypeKind.Double => "double",
            PrimitiveDataTypeKind.Float => "float",
            PrimitiveDataTypeKind.Integer => "int",
            PrimitiveDataTypeKind.UnsignedInteger => "uint",
            PrimitiveDataTypeKind.Void => "void",
            _ => string.Empty,
        };
    }

    private TemplateGroupString _hlslTemplate;
    private TemplateGroupString _baseTemplate;


    private string _currentBase = string.Empty;

    public Translator()
    {
        var hlslTemplate = "SPSL.Translation.Templates.Base.stg";
        var baseTemplate = "SPSL.Translation.Templates.HLSL.stg";

        using (Stream? stream = GetType().Assembly.GetManifestResourceStream(hlslTemplate))
        using (StreamReader reader = new StreamReader(stream!))
            _hlslTemplate = new TemplateGroupString("HLSL", reader.ReadToEnd());

        using (Stream? stream = GetType().Assembly.GetManifestResourceStream(baseTemplate))
        using (StreamReader reader = new StreamReader(stream!))
            _baseTemplate = new TemplateGroupString("Base", reader.ReadToEnd());

        _hlslTemplate.ImportTemplates(_baseTemplate);
    }

    public string Translate(AST ast)
    {
        StringBuilder output = new();

        output.Append("""
// <auto-generated>
// Code generated by Sparky Studios (R) SPSL to HLSL Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.


""");

        foreach (Namespace ns in ast)
        {
            output.Append(Translate(ns, ast));
        }

        output.Append("""

// End of auto-generated file.
// </auto-generated>
""");

        return output.ToString();
    }

    public string Translate(Namespace ns, AST ast)
    {
        StringBuilder output = new();

        foreach (INamespaceChild child in ns)
        {
            if (child is Language.AST.Type type)
                output.Append(Translate(type, ns, ast));
        }

        foreach (INamespaceChild child in ns)
        {
            if (child is Language.AST.Shader shader && shader.IsAbstract is false)
                output.Append(Translate(shader, ns, ast));
        }

        return output.ToString();
    }

    public string Translate(Language.AST.Type type, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        switch (type.Kind)
        {
            case Language.AST.TypeKind.Struct:
                {
                    Template template = _hlslTemplate.GetInstanceOf("struct");
                    template.Add("name", type.Name);
                    foreach (TypeMember member in type.Members)
                        template.Add("properties", new Prop(Translate(member.Type, ns, ast), member.Name));

                    output.AppendLine(template.Render());
                    output.AppendLine();
                    break;
                }
            case Language.AST.TypeKind.Enum:
                {
                    Template template = _hlslTemplate.GetInstanceOf("enum");
                    template.Add("name", type.Name);
                    foreach (TypeMember member in type.Members)
                        template.Add("properties", new Prop(Translate(member.Type, ns, ast), member.Name, member.Initializer != null ? Translate(member.Initializer, ns, ast) : null));

                    output.AppendLine(template.Render());
                    output.AppendLine();
                    break;
                }
        }

        return output.ToString();
    }

    public string Translate(ShaderFragment fragment, Namespace ns, AST ast, IEnumerable<ShaderFunction>? shouldOverride = null, IDictionary<string, uint>? conflicts = null)
    {
        StringBuilder output = new();
        HashSet<ShaderFunction> overriddenFunctions = new();

        foreach (IBlockChild child in fragment.Children)
            if (child is ShaderFunction function && function.IsOverride)
                overriddenFunctions.Add(function);

        if (fragment.ExtendedShaderFragment != NamespacedReference.Null)
        {
            INamespaceChild? parent = fragment.ExtendedShaderFragment.Resolve(ns);
            if (parent is ShaderFragment parentShaderFragment)
            {
                output.Append(Translate(parentShaderFragment, ns, ast, overriddenFunctions, conflicts));
            }
            else
            {
                output.AppendLine("// <spsl-error>");
                output.AppendLine($"// Shader fragment not found: {fragment.ExtendedShaderFragment.Name}. Make sure it exists or his namespace is imported.");
                output.AppendLine("// </spsl-error>");
                output.AppendLine();
            }
        }

        _currentBase = Translate(fragment.ExtendedShaderFragment, ns, ast);
        foreach (ShaderFunction function in fragment.Functions)
        {
            if ((shouldOverride is not null && shouldOverride.SingleOrDefault((m) => m.Function.Head.Equals(function.Function.Head)) is not null) ||
                (conflicts is not null && conflicts.ContainsKey(function.Function.Head.Name) && conflicts[function.Function.Head.Name] > 1))
                function.Function.Head.Name = $"{fragment.Name}_{function.Function.Head.Name}";


            output.AppendLine(Translate(function, ns, ast));
        }

        return output.ToString();
    }

    public string Translate(Shader shader, Namespace ns, AST ast, IEnumerable<ShaderFunction>? shouldOverride = null)
    {
        // 1. Process base shaders recursively
        //    - Rename overridden methods with BaseShader_MethodName
        // 2. Process shader fragments recursively
        //    - Latest shader fragment functions got predominance on previous ones if they have the same name.
        // 3. Process this shader
        //    - Calls to this are removed
        //    - Calls to base are renamed with the parent shader name

        StringBuilder output = new();
        HashSet<ShaderFunction> overriddenFunctions = new();

        foreach (IBlockChild child in shader.Children)
            if (child is ShaderFunction function && function.IsOverride)
                overriddenFunctions.Add(function);

        if (shader.ExtendedShader != NamespacedReference.Null)
        {
            INamespaceChild? parent = shader.ExtendedShader.Resolve(ns);
            if (parent is Shader parentShader)
            {
                output.Append(Translate(parentShader, ns, ast, overriddenFunctions));
            }
            else
            {
                output.AppendLine("// <spsl-error>");
                output.AppendLine($"// Shader not found: {shader.ExtendedShader.Name}. Make sure it exists or his namespace is imported.");
                output.AppendLine("// </spsl-error>");
                output.AppendLine();
            }
        }

        if (shader.ImportedShaderFragments.Count > 0)
        {
            Dictionary<string, uint> fragmentFunctions = new();

            foreach (NamespacedReference fragment in shader.ImportedShaderFragments)
            {
                if (fragment == NamespacedReference.Null)
                    continue;

                INamespaceChild? frag = fragment.Resolve(ns);
                if (frag is ShaderFragment shaderFragment)
                    foreach (IBlockChild child in shaderFragment.Children)
                        if (child is ShaderFunction function)
                            if (fragmentFunctions.ContainsKey(function.Function.Head.Name))
                                fragmentFunctions[function.Function.Head.Name] += 1;
                            else
                                fragmentFunctions.Add(function.Function.Head.Name, 1);
            }

            foreach (NamespacedReference fragment in shader.ImportedShaderFragments)
            {
                if (fragment == NamespacedReference.Null)
                    continue;

                INamespaceChild? frag = fragment.Resolve(ns);
                if (frag is ShaderFragment shaderFragment)
                {
                    output.Append(Translate(shaderFragment, ns, ast, null, fragmentFunctions));
                }
                else
                {
                    output.AppendLine("// <spsl-error>");
                    output.AppendLine($"// Shader fragment not found: {fragment.Name}. Make sure it exists or his namespace is imported.");
                    output.AppendLine("// </spsl-error>");
                    output.AppendLine();
                }
            }
        }

        _currentBase = Translate(shader.ExtendedShader, ns, ast);

        foreach (IBlockChild child in shader.Children)
        {
            if (child is ShaderFunction shaderFunction)
                if (shouldOverride is not null && shouldOverride.SingleOrDefault((m) => m.Function.Head.Equals(shaderFunction.Function.Head)) is not null)
                    shaderFunction.Function.Head.Name = $"{shader.Name}_{shaderFunction.Function.Head.Name}";

            string code = child switch
            {
                IStatement statement => Translate(statement, ns, ast),
                Function function => Translate(function, ns, ast),
                ShaderFunction sf => Translate(sf, ns, ast),
                _ => string.Empty,
            };

            output.AppendLine(code);
        }

        return output.ToString();
    }

    public string Translate(ShaderFunction function, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(Translate(function.Function, ns, ast));

        return output.ToString();
    }

    public string Translate(Function function, Namespace ns, AST ast)
    {
        StringBuilder output = new();
        output.Append(Translate(function.Head, ns, ast));
        output.Append(Translate(function.Body, ns, ast));

        return output.ToString();
    }

    public string Translate(FunctionHead head, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("func_head");
        template.Add("type", Translate(head.ReturnType, ns, ast));
        template.Add("name", head.Name);
        foreach (FunctionArgument arg in head.Signature.Parameters)
        {
            template.Add("args", new Arg(arg.Flow switch
            {
                DataFlow.In => "in",
                DataFlow.InOut => "inout",
                DataFlow.Out => "out",
                _ => null
            }, Translate(arg.Type, ns, ast), arg.Name));
        }

        output.AppendLine(template.Render());
        return output.ToString();
    }

    public string Translate(IDataType dataType, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        string code = dataType switch
        {
            BuiltInDataType builtInType => Translate(builtInType, ns, ast),
            PrimitiveDataType primitiveType => Translate(primitiveType, ns, ast),
            UnknownDataType unknownType => Translate(unknownType, ns, ast),
            UserDefinedDataType userDefinedType => Translate(userDefinedType, ns, ast),
            _ => string.Empty,
        };

        output.Append(code);
        return output.ToString();
    }

    public string Translate(BuiltInDataType builtInType, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(TranslateBuiltInType(builtInType.Type));

        return output.ToString();
    }

    public string Translate(PrimitiveDataType primitiveType, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(TranslatePrimitiveType(primitiveType.Type));

        return output.ToString();
    }

    public string Translate(UnknownDataType unknownType, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("__unknown_type__");

        return output.ToString();
    }

    public string Translate(UserDefinedDataType userDefinedType, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(Translate(userDefinedType.Type, ns, ast));

        return output.ToString();
    }

    public string Translate(IExpression expression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        string code = expression switch
        {
            IConstantExpression constantExpression => Translate(constantExpression, ns, ast),
            ArrayAccessExpression arrayAccessExpression => Translate(arrayAccessExpression, ns, ast),
            AssignmentExpression assignmentExpression => Translate(assignmentExpression, ns, ast),
            BasicExpression basicExpression => Translate(basicExpression, ns, ast),
            BinaryOperationExpression binaryExpression => Translate(binaryExpression, ns, ast),
            CastExpression castExpression => Translate(castExpression, ns, ast),
            InvocationExpression invocationExpression => Translate(invocationExpression, ns, ast),
            MethodMemberReferenceExpression methodMemberReferenceExpression => Translate(methodMemberReferenceExpression, ns, ast),
            NegateOperationExpression negateOperationExpression => Translate(negateOperationExpression, ns, ast),
            NewInstanceExpression newInstanceExpression => Translate(newInstanceExpression, ns, ast),
            ParenthesizedExpression parenthesizedExpression => Translate(parenthesizedExpression, ns, ast),
            PropertyMemberReferenceExpression propertyMemberReferenceExpression => Translate(propertyMemberReferenceExpression, ns, ast),
            TernaryOperationExpression ternaryOperationExpression => Translate(ternaryOperationExpression, ns, ast),
            UnaryOperationExpression unaryExpression => Translate(unaryExpression, ns, ast),
            _ => string.Empty
        };

        output.Append(code);
        return output.ToString();
    }

    public string Translate(IConstantExpression constantExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        string code = constantExpression switch
        {
            IPrimitiveExpression primitiveExpression => Translate(primitiveExpression, ns, ast),
            UserDefinedConstantExpression userDefinedConstantExpression => Translate(userDefinedConstantExpression, ns, ast),
            _ => string.Empty,
        };

        output.Append(code);
        return output.ToString();
    }

    public string Translate(IPrimitiveExpression primitiveExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        string code = primitiveExpression switch
        {
            ILiteral literal => Translate(literal, ns, ast),
            _ => string.Empty
        };

        output.Append(code);
        return output.ToString();
    }

    public string Translate(ILiteral literal, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        string code = literal switch
        {
            BoolLiteral boolLiteral => Translate(boolLiteral, ns, ast),
            DoubleLiteral doubleLiteral => Translate(doubleLiteral, ns, ast),
            FloatLiteral floatLiteral => Translate(floatLiteral, ns, ast),
            IntegerLiteral integerLiteral => Translate(integerLiteral, ns, ast),
            StringLiteral stringLiteral => Translate(stringLiteral, ns, ast),
            UnsignedIntegerLiteral unsignedIntegerLiteral => Translate(unsignedIntegerLiteral, ns, ast),
            _ => string.Empty
        };

        output.Append(code);
        return output.ToString();
    }

    public string Translate(BoolLiteral boolLiteral, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(boolLiteral.Value.ToString());

        return output.ToString();
    }

    public string Translate(DoubleLiteral doubleLiteral, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(doubleLiteral.Value.ToString());

        return output.ToString();
    }

    public string Translate(FloatLiteral floatLiteral, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(floatLiteral.Value.ToString());

        return output.ToString();
    }

    public string Translate(IntegerLiteral integerLiteral, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(integerLiteral.Value.ToString());

        return output.ToString();
    }

    public string Translate(StringLiteral literal, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(literal.Value);

        return output.ToString();
    }

    public string Translate(UnsignedIntegerLiteral unsignedIntegerLiteral, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(unsignedIntegerLiteral.Value.ToString());

        return output.ToString();
    }

    public string Translate(UserDefinedConstantExpression userDefinedConstantExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(Translate(userDefinedConstantExpression.Identifier, ns, ast));

        return output.ToString();
    }

    public string Translate(ArrayAccessExpression arrayAccessExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("array_access");
        template.Add("var", Translate(arrayAccessExpression.Expression, ns, ast));
        template.Add("idx", Translate(arrayAccessExpression.ArrayIndex, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(AssignmentExpression assignmentExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("binary_op");
        template.Add("lhs", Translate(assignmentExpression.Left, ns, ast));
        template.Add("op", TranslateOp(assignmentExpression.Operator));
        template.Add("rhs", Translate(assignmentExpression.Right, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(BasicExpression basicExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(basicExpression.Identifier);

        return output.ToString();
    }

    public string Translate(BinaryOperationExpression binaryExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template;

        // Use pow function instead
        if (binaryExpression.Operator == "^")
        {
            template = _hlslTemplate.GetInstanceOf("invocation");
            template.Add("function", "pow");
            template.Add("params", Translate(binaryExpression.Left, ns, ast));
            template.Add("params", Translate(binaryExpression.Right, ns, ast));

        }
        else
        {
            template = _hlslTemplate.GetInstanceOf("binary_op");
            template.Add("lhs", Translate(binaryExpression.Left, ns, ast));
            template.Add("op", TranslateOp(binaryExpression.Operator));
            template.Add("rhs", Translate(binaryExpression.Right, ns, ast));
        }

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(CastExpression castExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("cast");
        template.Add("type", Translate(castExpression.Type, ns, ast));
        template.Add("value", Translate(castExpression.Expression, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(InvocationExpression invocationExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("invocation");
        template.Add("function", Translate(invocationExpression.Name, ns, ast));

        foreach (InvocationParameter parameter in invocationExpression.Parameters)
            template.Add("params", Translate(parameter.Expression, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(MethodMemberReferenceExpression methodMemberReferenceExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template;

        // Calls to this are ignored
        if (methodMemberReferenceExpression.Target == "this")
        {
            template = _hlslTemplate.GetInstanceOf("invocation");
            template.Add("function", methodMemberReferenceExpression.Member.Name);
        }
        // Calls to base are renamed
        else if (methodMemberReferenceExpression.Target == "base")
        {
            template = _hlslTemplate.GetInstanceOf("invocation");
            template.Add("function", $"{_currentBase}_{methodMemberReferenceExpression.Member.Name}");
        }
        else
        {
            template = _hlslTemplate.GetInstanceOf("member_invocation");
            template.Add("owner", methodMemberReferenceExpression.Target);
            template.Add("function", methodMemberReferenceExpression.Member.Name);
        }

        foreach (InvocationParameter parameter in methodMemberReferenceExpression.Member.Parameters)
            template.Add("params", Translate(parameter.Expression, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(NegateOperationExpression negateOperationExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("!");
        output.Append(Translate(negateOperationExpression.Expression, ns, ast));

        return output.ToString();
    }

    public string Translate(NewInstanceExpression newInstanceExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("new_instance");
        template.Add("type", Translate(newInstanceExpression.Type, ns, ast));

        foreach (InvocationParameter argument in newInstanceExpression.Parameters)
            template.Add("params", Translate(argument.Expression, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(ParenthesizedExpression parenthesizedExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("(");
        output.Append(Translate(parenthesizedExpression.Expression, ns, ast));
        output.Append(")");

        return output.ToString();
    }

    public string Translate(PropertyMemberReferenceExpression propertyMemberReferenceExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        // Calls to this are ignored
        if (propertyMemberReferenceExpression.Target == "this")
        {
            output.Append(propertyMemberReferenceExpression.Member);
        }
        // Calls to base are renamed
        else if (propertyMemberReferenceExpression.Target == "base")
        {
            output.Append($"{_currentBase}_{propertyMemberReferenceExpression.Member}");
        }
        else
        {
            output.Append($"{propertyMemberReferenceExpression.Target}.{propertyMemberReferenceExpression.Member}");
        }

        return output.ToString();
    }

    public string Translate(TernaryOperationExpression ternaryOperationExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("ternary_op");
        template.Add("condition", Translate(ternaryOperationExpression.Condition, ns, ast));
        template.Add("lhs", Translate(ternaryOperationExpression.WhenTrue, ns, ast));
        template.Add("rhs", Translate(ternaryOperationExpression.WhenFalse, ns, ast));

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(UnaryOperationExpression unaryExpression, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("unary_op");
        template.Add("op", TranslateOp(unaryExpression.Operator));
        template.Add("expression", Translate(unaryExpression.Expression, ns, ast));
        template.Add("isPostfix", unaryExpression.IsPostfix);

        output.Append(template.Render());
        return output.ToString();
    }

    private string Translate(VariableDeclarationStatement variableDeclarationStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("variable_declaration");
        template.Add("type", Translate(variableDeclarationStatement.Type, ns, ast));
        template.Add("name", Translate(variableDeclarationStatement.Name, ns, ast));

        if (variableDeclarationStatement.Initializer != null)
            template.Add("initializer", Translate(variableDeclarationStatement.Initializer, ns, ast));

        template.Add("isArray", variableDeclarationStatement.Type.IsArray);
        template.Add("arraySize", variableDeclarationStatement.Type.ArraySize);

        output.Append(template.Render());
        return output.ToString();
    }

    public string Translate(IStatement statement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        bool needComma = true;
        if (statement is BreakStatement breakStatement)
        {
            output.Append(Translate(breakStatement, ns, ast));
        }
        else if (statement is ContinueStatement continueStatement)
        {
            output.Append(Translate(continueStatement, ns, ast));
        }
        else if (statement is DiscardStatement discardStatement)
        {
            output.Append(Translate(discardStatement, ns, ast));
        }
        else if (statement is ExpressionStatement expressionStatement)
        {
            output.Append(Translate(expressionStatement, ns, ast));
        }
        else if (statement is IfStatement ifStatement)
        {
            output.Append(Translate(ifStatement, ns, ast));
            needComma = false;
        }
        else if (statement is ReturnStatement ret)
        {
            output.Append(Translate(ret, ns, ast));
        }
        else if (statement is StatementBlock block)
        {
            output.Append(Translate(block, ns, ast));
            needComma = false;
        }
        else if (statement is StatementCollection statementCollection)
        {
            output.Append(Translate(statementCollection, ns, ast));
            needComma = false;
        }
        else if (statement is VariableDeclarationStatement variableDeclarationStatement)
        {
            output.Append(Translate(variableDeclarationStatement, ns, ast));
        }


        if (needComma)
            output.Append(";");

        return output.ToString();
    }

    public string Translate(BreakStatement breakStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("break");

        return output.ToString();
    }

    public string Translate(ContinueStatement continueStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("continue");

        return output.ToString();
    }

    public string Translate(DiscardStatement discardStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("discard");

        return output.ToString();
    }

    public string Translate(ExpressionStatement expressionStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append(Translate(expressionStatement.Expression, ns, ast));

        return output.ToString();
    }

    public string Translate(IfStatement ifStatement, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("if (");
        output.Append(Translate(ifStatement.If.Condition, ns, ast));
        output.AppendLine(")");
        output.Append(Translate(ifStatement.If.Block, ns, ast));

        foreach (IfStatement.IfStatementConditionBlock elif in ifStatement.Elif)
        {
            output.Append("else if (");
            output.Append(Translate(elif.Condition, ns, ast));
            output.AppendLine(")");
            output.Append(Translate(elif.Block, ns, ast));
        }

        if (ifStatement.Else != null)
        {
            output.AppendLine("else");
            output.Append(Translate(ifStatement.Else, ns, ast));
        }

        return output.ToString();
    }

    public string Translate(ReturnStatement ret, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        output.Append("return");

        if (ret.Expression != null)
        {
            output.Append(" ");
            output.Append(Translate(ret.Expression, ns, ast));
        }

        return output.ToString();
    }

    public string Translate(StatementCollection statementCollection, Namespace ns, AST ast)
    {
        StringBuilder output = new();
        List<string> statements = new();

        foreach (IStatement statement in statementCollection.Statements)
            statements.Add(Translate(statement, ns, ast));

        output.Append(string.Join('\n', statements));
        return output.ToString();
    }

    public string Translate(StatementBlock body, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        Template template = _hlslTemplate.GetInstanceOf("statements_block");
        foreach (IBlockChild child in body.Children)
        {
            if (child is IStatement statement)
                template.Add("stats", Translate(statement, ns, ast));
        }

        output.AppendLine(template.Render());
        return output.ToString();
    }

    public string Translate(NamespacedReference reference, Namespace ns, AST ast)
    {
        StringBuilder output = new();

        var name = $"'{reference.Name}'";

        if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR2B))
            output.Append("bool2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR2F))
            output.Append("float2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR2I))
            output.Append("int2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR2UI))
            output.Append("uint2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR3B))
            output.Append("bool3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR3F))
            output.Append("float3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR3I))
            output.Append("int3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR3UI))
            output.Append("uint3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR4B))
            output.Append("bool4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR4F))
            output.Append("float4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR4I))
            output.Append("int4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_VECTOR4UI))
            output.Append("uint4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX2F))
            output.Append("float2x2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX3F))
            output.Append("float3x3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX4F))
            output.Append("float4x4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX2X3F))
            output.Append("float2x3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX2X4F))
            output.Append("float2x4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX3X2F))
            output.Append("float3x2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX3X4F))
            output.Append("float3x4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX4X2F))
            output.Append("float4x2");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_MATRIX4X3F))
            output.Append("float4x3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_COLOR3))
            output.Append("float3");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_COLOR4))
            output.Append("float4");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_SAMPLER))
            output.Append("SamplerState");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_TEXTURE1D))
            output.Append("Texture1D");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_TEXTURE2D))
            output.Append("Texture2D");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_TEXTURE1DARRAY))
            output.Append("Texture1DArray");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_TEXTURE2DARRAY))
            output.Append("Texture2DArray");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_TEXTURE3D))
            output.Append("Texture3D");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_CUBEMAP))
            output.Append("TextureCube");
        else if (name == SPSLLexer.DefaultVocabulary.GetLiteralName(SPSLLexer.TYPE_CUBEMAPARRAY))
            output.Append("TextureCubeArray");
        else
        {
            var type = reference.Resolve(ns);
            if (type is Language.AST.Type spslType)
            {
                if (spslType.Kind == TypeKind.Enum)
                    output.Append("uint");
                else
                    output.Append(spslType.Name);
            }
            else
            {
                output.Append(reference.Name.Replace('\\', '_'));
            }
        }

        return output.ToString();
    }
}
