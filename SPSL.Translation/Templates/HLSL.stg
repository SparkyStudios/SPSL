group HLSL: Base;

// SPSL translator template for HLSL

// Constant Buffer
cbuffer(name, binding, set, properties) ::= <<
struct buffer_<name>
{
  <properties:prop(); separator = ";\n">;
};

cbuffer <name> : register(b<binding>, space<set>)
{
  buffer_<name> <name>;
};
>>

// ReadWrite Buffer
rwbuffer(name, binding, set, properties, isCoherent) ::= <<
struct buffer_<name>
{
  <properties:prop(); separator = ";\n">;
};

<if(isCoherent)>globallycoherent <endif>RWStructuredBuffer\<buffer_<name>\> <name> : register(b<binding>, space<set>);
>>

// Structure
struct(name, properties, functions) ::= <<
struct <name>
{
  <if(properties)>
  <properties:prop(); separator = ";\n">;
  <endif>
  <if(functions)>

  <functions; separator = "\n\n">
  <endif>
};
>>

// Enumeration
enum(name, properties) ::= <<
<properties:{p|const <p.type> <name>_<p.name> = <p.value>}; separator = ";\n">;
>>

// Global Variable
const_global_var(isStatic, type, name, initializer) ::= <<
<if(isStatic)>static <endif>const <type> <name> = <initializer>;
>>

// Type cast
cast(type, value) ::= "(<type>)<value>"

member_invocation(owner, function, params) ::= "<owner>.<invocation(function, params)>"

new_instance(type, params) ::= "<invocation(type, params)>"

// Permutation Variable
permutation_var(m, enum_values) ::= <<
<if(enum_values)>
<enum_values:macro(); separator = "\n">
<endif>
<m:macro()>
>>

// Permute block
permute_block(condition, block, otherwise) ::= <<
#if <condition>
<block>
<if(otherwise)>
#else
<otherwise>
<endif>
#endif
>>
